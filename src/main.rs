use std::fs;
use std::path::{Path, PathBuf};

use anyhow::anyhow;
use anyhow::Result;
use clap::Parser;
use rattler_conda_types::{ExplicitEnvironmentEntry, ExplicitEnvironmentSpec, Platform};
use rattler_lock::{
    CondaPackage, LockFile, Package, PackageHashes, PypiPackage, PypiPackageData, UrlOrPath,
};
use tracing_log::AsTrace;

fn cwd() -> PathBuf {
    std::env::current_dir().expect("failed to obtain current working directory")
}

#[derive(clap::Parser)]
#[command(version, about, long_about = None)]
struct Cli {
    /// Environment to render
    #[arg(short, long, default_value = "default")]
    environment: String,

    /// Platform to render
    #[arg(short, long, default_value = Platform::current().as_str())]
    platform: Platform,

    /// The path to 'pixi.toml' or 'pyproject.toml'
    #[arg(default_value = cwd().join("pixi.toml").into_os_string())]
    manifest_path: PathBuf,

    /// PyPI dependencies are not supported in the conda spec file.
    /// This flag allows creaing the spec file even if PyPI dependencies are present.
    /// Alternatively see --write-pypi-requirements
    #[arg(long, default_value = "false")]
    ignore_pypi_errors: bool,

    /// Write a requirements file containing all pypi dependencies
    #[arg(long, default_value = "false", conflicts_with = "ignore_pypi_errors")]
    write_pypi_requirements: bool,

    #[command(flatten)]
    verbose: clap_verbosity_flag::Verbosity,
}

fn build_explicit_spec<'a>(
    platform: Platform,
    conda_packages: impl IntoIterator<Item = &'a CondaPackage>,
) -> Result<ExplicitEnvironmentSpec> {
    let mut packages = Vec::new();

    for cp in conda_packages {
        let prec = cp.package_record();
        let mut url = cp.url().to_owned();
        let hash = prec.md5.ok_or(anyhow!(
            "Package {} does not contain an md5 hash",
            prec.name.as_normalized()
        ))?;

        url.set_fragment(Some(&format!("{:x}", hash)));

        packages.push(ExplicitEnvironmentEntry {
            url: url.to_owned(),
        });
    }

    Ok(ExplicitEnvironmentSpec {
        platform: Some(platform),
        packages,
    })
}

fn write_explicit_spec(
    target: impl AsRef<Path>,
    exp_env_spec: &ExplicitEnvironmentSpec,
) -> Result<()> {
    let mut environment = String::new();
    environment.push_str("# Generated by pixi :: pixi2ces\n");
    environment.push_str(exp_env_spec.to_spec_string().as_str());

    fs::write(target, environment)
        .map_err(|e| anyhow!("Could not write environment file: {}", e))?;

    Ok(())
}

fn get_pypi_hash_str(package_data: &PypiPackageData) -> Option<String> {
    if let Some(hashes) = &package_data.hash {
        let h = match hashes {
            PackageHashes::Sha256(h) => format!("--hash=sha256:{:x}", h).to_string(),
            PackageHashes::Md5Sha256(_, h) => format!("--hash=sha256:{:x}", h).to_string(),
            PackageHashes::Md5(h) => format!("--hash=md5:{:x}", h).to_string(),
        };
        Some(h)
    } else {
        None
    }
}

fn write_pypi_requirements(target: impl AsRef<Path>, packages: &[PypiPackage]) -> Result<()> {
    let mut reqs = String::new();

    for p in packages {
        // pip --verify-hashes does not accept hashes for local files
        let (s, include_hash) = match p.url() {
            UrlOrPath::Url(url) => (url.as_str(), true),
            UrlOrPath::Path(path) => (
                path.as_os_str()
                    .to_str()
                    .unwrap_or_else(|| panic!("Could not convert {:?} to str", path)),
                false,
            ),
        };

        // remove "direct+ since not valid for pip urls"
        let s = s.trim_start_matches("direct+");

        let hash = match (include_hash, get_pypi_hash_str(p.data().package)) {
            (true, Some(h)) => format!(" {}", h),
            (false, _) => "".to_string(),
            (_, None) => "".to_string(),
        };

        if p.is_editable() {
            reqs.push_str(&format!("-e {}{}\n", s, hash));
        } else {
            reqs.push_str(&format!("{}{}\n", s, hash));
        }
    }

    fs::write(target, reqs).map_err(|e| anyhow!("Could not write requirements file: {}", e))?;

    Ok(())
}

fn main() -> Result<()> {
    let options = Cli::parse();

    tracing_subscriber::FmtSubscriber::builder()
        .with_max_level(options.verbose.log_level_filter().as_trace())
        .init();

    tracing::debug!("Starting pixi2ces CLI");

    let lockfile_path = options
        .manifest_path
        .parent()
        .ok_or(anyhow!("could not get parent directory"))?
        .join("pixi.lock");

    let lockfile = LockFile::from_path(&lockfile_path).map_err(|e| {
        anyhow!(
            "could not read lockfile at {}: {}",
            lockfile_path.display(),
            e
        )
    })?;

    let env = lockfile.environment(&options.environment).ok_or(anyhow!(
        "environment not found in lockfile: {}",
        options.environment
    ))?;

    let packages = env.packages(options.platform).ok_or(anyhow!(
        "platform not found in lockfile: {}",
        options.platform.as_str()
    ))?;

    let mut conda_packages_from_lockfile: Vec<CondaPackage> = Vec::new();
    let mut pypi_packags_from_lockfile: Vec<PypiPackage> = Vec::new();

    for package in packages {
        match package {
            Package::Conda(p) => conda_packages_from_lockfile.push(p),
            Package::Pypi(pyp) => {
                if options.ignore_pypi_errors {
                    tracing::warn!("ignoring PyPI package since PyPI packages are not supported");
                } else if options.write_pypi_requirements {
                    pypi_packags_from_lockfile.push(pyp);
                } else {
                    anyhow::bail!("PyPI packages are not supported. Specify `--ignore-pypi-errors` to ignore this error");
                }
            }
        }
    }

    let ees = build_explicit_spec(options.platform, &conda_packages_from_lockfile)?;

    tracing::info!("Creating conda lock file");
    let target = cwd()
        .join(format!(
            "conda-{}-{}.lock",
            options.platform, options.environment
        ))
        .into_os_string();

    write_explicit_spec(target, &ees)?;

    if options.write_pypi_requirements {
        tracing::info!("Creating conda lock file");
        let pypi_target = cwd()
            .join(format!(
                "requirements-{}-{}.txt",
                options.platform, options.environment
            ))
            .into_os_string();

        write_pypi_requirements(pypi_target, &pypi_packags_from_lockfile)?;
    }

    Ok(())
}
